#!/bin/bash

timestamp=$(date "+%Y-%m-%d %H:%M:%S")
start_time=$(date "+%Y-%m-%d %H:%M:%S")
start_seconds=$(date +%s)
PROJECT_DIR="$(pwd)"
NEW_ENTRY="$1"
ENTRY_POINT="$2"
APP_TYPE=${3:-terminal}
DEST_ARG=${4:-$(pwd)/}
DIST_PATH="$PROJECT_DIR/dist"
BUILD_PATH="$PROJECT_DIR/build"
OS_TYPE=$(uname -s)
OS_ARCH=$(uname -m)

# If you need to use sudo commands you will need to uncomment these lines. (239, 241, 279, 281)
# just make sure you comment out the non sudo commands

# SUDO="/usr/bin/sudo"
# or
# SUDO="/bin/sudo"

MKDIR="/usr/bin/mkdir"
RM="/usr/bin/rm"
DATE="/usr/bin/date"
CP="/usr/bin/cp"
MV="/usr/bin/mv"
CHMOD="/usr/bin/chmod"
DIRNAME="/usr/bin/dirname"
BASENAME="/usr/bin/basename"
CAT="/usr/bin/cat"

[[ "${DEST_ARG: -1}" != "/" ]] && DEST_ARG="${DEST_ARG}/"

mkdir -p "$DEST_ARG" || {
    echo "Error: Could not create or access destination directory $DEST_ARG" >&2
    exit 1
}
OUTPUT_NAME=$(basename "$NEW_ENTRY")
SPEC_PATH=$(basename "$NEW_ENTRY" .spec)
FINAL_DIST_PATH="$DEST_ARG$NEW_ENTRY"
if [[ "$OS_TYPE" == *"MINGW"* || "$OS_TYPE" == *"CYGWIN"* ]]; then
    FINAL_DIST_PATH="$(cygpath -m "$FINAL_DIST_PATH")"
fi
for cmd in $MKDIR $RM $DATE $CP $MV $CHMOD $DIRNAME $BASENAME; do
    if [ ! -x "$cmd" ]; then
        echo "CRITICAL ERROR: Missing $cmd" >&2
        echo "Your MSYS2 environment is broken. Please:" >&2
        echo "1. Restart your MSYS2 terminal" >&2
        echo "2. Run: pacman -Syu" >&2
        echo "3. Run: pacman -S --needed base-devel msys2-runtime" >&2
        exit 1
    fi
done
# Try to fix PATH if broken
if ! command -v mkdir >/dev/null; then
    echo -e "\e[1;33m[WARNING]\e[0m PATH appears broken, attempting to fix..." >&2
    export PATH="/usr/bin:/bin:/mingw64/bin:$PATH"
fi
gen_uninstall() {
    local os_type="$1"
    if [ -z "${os_type}" ]; then
        echo -e "\e[1;31mError: OS_Type must be provided before uninstall can be generated.\e[0m" >&2
        echo -e "\e[1;31mError: Uninstall generation did not complete.\e[0m" >&2
        return 1
    fi
    local project_dir="$2"
    if [ -z "${project_dir}" ]; then
        echo -e "\e[1;31mError: Project directory must be provided before uninstall can be generated.\e[0m" >&2
        echo -e "\e[1;31mError: Uninstall generation did not complete.\e[0m" >&2
        return 1
    fi
    local output_name="$3"
    if [ -z "${output_name}" ]; then
        echo -e "\e[1;31mError: Output name must be provided before uninstall can be generated.\e[0m" >&2
        echo -e "\e[1;31mError: Uninstall generation did not complete.\e[0m" >&2
        return 1
    fi
    local final_dist_path="$4"
    if [ -z "${final_dist_path}" ]; then
        echo -e "\e[1;31mError: Destination directory must be provided before uninstall can be generated.\e[0m" >&2
        echo -e "\e[1;31mError: Uninstall generation did not complete.\e[0m" >&2
        return 1
    fi
    local uninstall_script="${project_dir}/uninstall_${output_name}.sh"
    $CAT > "$uninstall_script" <<EOF
#!/bin/bash

# Uninstaller for $output_name
# Generated by CrudePyBuild

# Configuration
RM="/usr/bin/rm"
CHMOD="/usr/bin/chmod"

# Check if binary exists
if [ ! -f "$final_dist_path" ]; then
    echo -e "\e[1;31mError: $output_name not found at $final_dist_path\e[0m" >&2
    echo -e "\e[1;33mIt may have already been uninstalled\e[0m" >&2
    exit 1
fi

echo -e "\e[1;36mUninstalling $output_name...\e[0m"
echo -e "\e[1;33mRemoving: $final_dist_path\e[0m"

# Remove the binary
if ! \$RM -f "$final_dist_path"; then
    echo -e "\e[1;31mFailed to remove $final_dist_path\e[0m" >&2
    echo -e "\e[1;33mYou may need to run this script with sudo\e[0m" >&2
    exit 1
fi

# Remove supporting files based on OS
case "$os_type" in
    Linux*)
        echo -e "\e[1;34mRemoving Linux-specific files...\e[0m"
        \$RM -rf "/usr/local/share/$output_name"
        \$RM -rf "/usr/local/etc/$output_name"
        \$RM -rf "~/.config/$output_name"
        \$RM -rf "~/.local/share/$output_name"
        ;;
    MINGW*|CYGWIN*)
        echo -e "\e[1;34mRemoving Windows/MSYS2-specific files...\e[0m"
        \$RM -rf "/usr/local/share/$output_name"
        \$RM -rf "/etc/$output_name"
        \$RM -rf "\$HOME/.config/$output_name"
        \$RM -rf "\$HOME/AppData/Roaming/$output_name"
        \$RM -rf "\$HOME/AppData/Local/$output_name"
        ;;
    Darwin*)
        echo -e "\e[1;34mRemoving macOS-specific files...\e[0m"
        \$RM -rf "/usr/local/share/$output_name"
        \$RM -rf "/usr/local/etc/$output_name"
        \$RM -rf "\$HOME/Library/Application Support/$output_name"
        \$RM -rf "\$HOME/Library/Preferences/$output_name"
        ;;
    *)
        echo -e "\e[1;33mUnknown OS type. Only removing main binary.\e[0m" >&2
        ;;
esac

echo -e "\e[1;32mSuccessfully uninstalled $output_name\e[0m"
echo -e "\e[1;36mYou may manually remove any remaining configuration files if needed\e[0m"

exit 0
EOF
    $CHMOD +x "$uninstall_script"
    echo -e "\e[1;32m‚úì Created uninstaller\e[0m"
    echo -e "\e[1;33mTo uninstall, run: .$uninstall_script\e[0m"
}

create_directory() {
    local dir_path="$1"
    echo -e "\e[1;36mCreating directory path: \e[1;35m$dir_path\e[0m"
    if [ -d "$dir_path" ]; then
        echo -e "\e[1;33mDirectory already exists\e[0m"
        return 0
    fi
    if ! $MKDIR -p "$dir_path"; then
        echo -e "\e[1;31mError: Failed to create directory path: \e[1;35m$dir_path\e[0m" >&2
        exit 1
    fi
    echo -e "\e[1;32m‚úì Directory created successfully\e[0m"
}
echo ""
echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
echo -e "\e[1;34mCrudePyBuild \e[1;35mv0.0.1\e[0m"
echo -e "\e[1;33mBuild started: \e[1;32m$timestamp\e[0m"
echo ""
echo -e "\e[1;37mBuild process for \e[1;32m$OUTPUT_NAME\e[1;37m has started.\e[0m"
echo -e "\e[1;37mApplication Type: \e[1;33m$APP_TYPE\e[0m"
echo -e "\e[1;37mEntry Point: \e[1;33m$ENTRY_POINT\e[0m"
echo -e "\e[1;37mProject Path: \e[1;33m$PROJECT_DIR\e[0m"
echo -e "\e[1;37mDestination Path: \e[1;33m$FINAL_DIST_PATH\e[0m"
echo -e "\e[1;37mOS: \e[1;33m$OS_TYPE\e[0m"
echo -e "\e[1;37mArch: \e[1;33m$OS_ARCH\e[0m"
echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
echo ""
echo -e "\e[1;37mAre you sure you want to continue with this build?:\e[0m"
echo -e "\e[1;32m1. Yes\e[0m"
echo -e "\e[1;31m2. Abort\e[0m"
read -rp "Enter your choice (1/2): " BUILD_CHOICE
case "$BUILD_CHOICE" in
    1)
        echo -e "\e[1;32m‚úì Continuing with build...\e[0m"
        start_time=$(date "+%Y-%m-%d %H:%M:%S")
        start_seconds=$(date +%s)
        ;;
    2)
        echo -e "\e[1;31m‚úó Build aborted by user.\e[0m" >&2
        exit 1
        ;;
    *)
        echo -e "\e[1;31m‚ö† Invalid choice. Build aborted.\e[0m" >&2
        exit 1
        ;;
esac

# Check for virtual environment
if [ ! -d ".venv" ]; then
    echo -e "\n\e[1;33m‚öô .venv not found. Creating virtual environment...\e[0m"
    python3 -m venv .venv
fi

# Activate virtual environment
echo -e "\n\e[1;34müîå Activating virtual environment...\e[0m"
source .venv/bin/activate
. .venv/bin/activate  # Ensures activation (redundant but safe)

# Install PyInstaller quietly
echo -e "\n\e[1;35m‚Üì Installing PyInstaller...\e[0m"
pip install pyinstaller --quiet

# Freeze requirements
echo -e "\n\e[1;36m‚ùÑ Freezing Required Modules\e[0m"
pip freeze > requirements.txt

# Install requirements
echo -e "\n\e[1;32m‚úî Checking Requirements\e[0m"
pip install -r requirements.txt --quiet

# Create build directories if missing
if [ ! -d "$BUILD_PATH" ]; then
    echo -e "\e[1;33müìÇ Creating '$BUILD_PATH'\e[0m"
    mkdir -p "$BUILD_PATH"
fi

if [ ! -d "$DIST_PATH" ]; then
    echo -e "\e[1;33müìÇ Creating '$DIST_PATH'\e[0m"
    mkdir -p "$DIST_PATH"
fi
echo ""
echo -e "\e[1;34m[üöÄ Building] \e[1;36mBinary with PyInstaller...\e[0m"
PYINSTALLER_FLAGS="--specpath $PROJECT_DIR/$SPEC_PATH --distpath $DIST_PATH --onefile --name $NEW_ENTRY"
if [ "$APP_TYPE" = "gui" ]; then
    echo -e "\e[1;36müõ†Ô∏è  Configuring build for GUI application...\e[0m"
    echo "$OS_TYPE"
    if [[ "$OS_TYPE" == "MINGW"* || "$OS_TYPE" == "CYGWIN"* ]]; then
        PYINSTALLER_FLAGS="$PYINSTALLER_FLAGS --windowed --noconsole"
    else
        PYINSTALLER_FLAGS="$PYINSTALLER_FLAGS --windowed"
    fi
else
    echo -e "\e[1;33müíª Configuring build for terminal application...\e[0m"
fi
if [[ "$OS_TYPE" == "Linux" ]]; then
    echo ""
    echo -e "\e[1;36müñ•Ô∏è Building for Linux...\e[0m"
    pyinstaller $PYINSTALLER_FLAGS "$PROJECT_DIR/$ENTRY_POINT"
    #rename $PROJECT_DIR/$ENTRY_POINT $PROJECT_DIR/$OUTPUT_NAME
elif [[ "$OS_TYPE" == "MINGW"* || "$OS_TYPE" == "CYGWIN"* ]]; then
    echo ""
    echo -e "\e[1;32mü™ü Building for Windows...\e[0m"
    PYINSTALLER_FLAGS="$PYINSTALLER_FLAGS --hidden-import win32security --hidden-import win32gui --hidden-import win32timezone"
    pyinstaller $(echo $PYINSTALLER_FLAGS) "$PROJECT_DIR/$ENTRY_POINT"
    #rename $PROJECT_DIR/$ENTRY_POINT $PROJECT_DIR/$OUTPUT_NAME
else
    echo ""
    echo -e "\e[1;31m‚ùå Unsupported OS: $OS_TYPE\e[0m" >&2
    exit 1
fi
BINARY_PATH="$DIST_PATH/$OUTPUT_NAME"
echo -e "\e[1;36m"
echo "Select an action for the binary:"
echo -e "\e[1;33m1. \e[1;32mMove to \e[1;35m$FINAL_DIST_PATH\e[0m"
echo -e "\e[1;33m2. \e[1;32mCopy to \e[1;35m$FINAL_DIST_PATH\e[0m"
echo -e "\e[1;33m3. \e[1;31mSkip Both\e[0m"
read -rp "Enter your choice (1/2/3): " CHOICE
case $CHOICE in
  1)

    echo -e "\e[1;36m"
    echo -e "üöö Moving \e[1;33m$BINARY_PATH\e[1;36m to \e[1;35m$FINAL_DIST_PATH\e[0m"
    create_directory "$($DIRNAME "$FINAL_DIST_PATH")"
    $MV "$BINARY_PATH" "$FINAL_DIST_PATH"
    #$SUDO $MV "$BINARY_PATH" "$FINAL_DIST_PATH" && \
    $CHMOD +x "$FINAL_DIST_PATH"
    #$SUDO $CHMOD +x "$FINAL_DIST_PATH"
    echo -e "\e[1;32m‚úì Move complete.\e[0m"
    echo -e "\e[1;36müîí Setting executable permissions for \e[1;35m$FINAL_DIST_PATH\e[0m"
    sudo chmod +x "$FINAL_DIST_PATH"
    echo -e "\e[0m"

    echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
    echo -e "üéâ \e[1;32mDone! \e[0mExecute the application anywhere by typing: \e[1;33m'$OUTPUT_NAME'\e[0m."
    echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
    echo ""
    echo -e "\e[1;35müßπ Remove build artifacts?:\e[0m"
    echo -e "\e[1;32m1. Yes they can be deleted\e[0m"
    echo -e "\e[1;33m2. No I want to keep them\e[0m"
    read -rp "Enter your choice (1/2): " DEL_CHOICE
    case $DEL_CHOICE in
    1)
      echo ""
      echo -e "\e[1;31müóëÔ∏è Removing build artifacts...\e[0m"
      rm -rf dist/ build/ *.spec
      echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
      echo -e "\e[1;32m‚úì Build artifacts have been removed.\e[0m"
      echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
      ;;
    2)
      echo ""
      echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
      echo -e "\e[1;33müì¶ Build artifacts preserved in their respective directories.\e[0m"
      echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
      ;;
    esac
    ;;
  2)
    echo ""
    echo -e "\e[1;34müìã Copying \e[1;33m$BINARY_PATH\e[1;34m to \e[1;35m$FINAL_DIST_PATH\e[0m"
    create_directory "$($DIRNAME "$FINAL_DIST_PATH")"
    $CP "$BINARY_PATH" "$FINAL_DIST_PATH" && \
    echo -e "\e[1;36müîí Setting executable permissions for \e[1;35m$FINAL_DIST_PATH\e[0m"
    $CHMOD +x "$FINAL_DIST_PATH"
    echo -e "\e[1;32m‚úì Copy complete.\e[0m"
    echo ""
    echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
    echo -e "üéâ \e[1;32mDone! \e[0mExecute the application anywhere by typing: \e[1;33m'$OUTPUT_NAME'\e[0m."
    echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
    echo ""
    echo -e "\e[1;35müßπ Remove build artifacts?:\e[0m"
    echo -e "\e[1;32m1. Yes: They can be deleted\e[0m"
    echo -e "\e[1;33m2. No: I want to keep them\e[0m"
    read -rp "Enter your choice (1/2): " DEL_CHOICE
    case $DEL_CHOICE in
      1)
        echo ""
        echo -e "\e[1;31müóëÔ∏è Removing build artifacts...\e[0m"
        rm -rf dist/ build/ $NEW_ENTRY/*.spec $NEW_ENTRY
        echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
        echo -e "\e[1;32m‚úì Build artifacts have been removed.\e[0m"
        echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
        ;;
      2)
        echo ""
        echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
        echo -e "\e[1;33müì¶ Build artifacts preserved in their respective directories.\e[0m"
        echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
        ;;
    esac
    ;;
  3)
    echo ""
    echo -e "\e[1;33m‚è≠Ô∏è Move and Copy have been skipped. Binary can be located here: \e[1;35m$BINARY_PATH\e[0m"
    echo -e "\e[1;36müîí Setting executable permissions for \e[1;35m$BINARY_PATH\e[0m"
    $CHMOD +x "$BINARY_PATH"
    echo ""
    echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
    echo -e "üéâ \e[1;32mDone! \e[0mExecute the application in its binary directory by typing: \e[1;33m'$OUTPUT_NAME'\e[0m."
    echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
    ;;
  *)
    echo ""
    echo -e "\e[1;31m‚ö†Ô∏è Invalid choice. No action taken.\e[0m"
    #echo -e "\e[1;36müîí Setting executable permissions for \e[1;35m$BINARY_PATH\e[0m"
    #$CHMOD +x "$BINARY_PATH"
    #echo ""
    #echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
    #echo -e "üéâ \e[1;32mDone! \e[0mExecute the application in its binary directory by typing: \e[1;33m'$OUTPUT_NAME'\e[0m."
    #echo -e "\e[1;36m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\e[0m"
    ;;
esac
gen_uninstall "$OS_TYPE" "$PROJECT_DIR" "$OUTPUT_NAME"  "$FINAL_DIST_PATH"
done_stamp=$(date "+%Y-%m-%d %H:%M:%S")
end_seconds=$(date +%s)
# Calculate time difference
time_diff=$((end_seconds - start_seconds))
# Convert seconds to human readable format
if (( time_diff < 60 )); then
    time_lapse="${time_diff} seconds"
elif (( time_diff < 3600 )); then
    minutes=$((time_diff / 60))
    seconds=$((time_diff % 60))
    time_lapse="${minutes}m ${seconds}s"
else
    hours=$((time_diff / 3600))
    minutes=$(( (time_diff % 3600) / 60 ))
    seconds=$((time_diff % 60))
    time_lapse="${hours}h ${minutes}m ${seconds}s"
fi
echo -e "\e[1;36m‚è±Ô∏è  Build ended: \e[1;35m$done_stamp\e[0m"
echo -e "\e[1;36m‚è≥ Build started at: \e[1;35m$start_time\e[0m"
echo -e "\e[1;36müöÄ This build took: \e[1;33m$time_lapse\e[0m \e[1;36mto complete.\e[0m"
